"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const moment = require("moment");
const readDirectory_1 = require("../utils/readDirectory");
const Utils_1 = require("../utils/Utils");
const Listener_1 = require("../modules/Listener");
class Logger4 extends Listener_1.Listener {
    constructor({ path = null, directorySizeLimitMB = null }) {
        super();
        this._target = { '': null };
        this._types = [''];
        this._directorySizeLimitMB = null;
        this._timeout = null;
        this._path = path;
        this._directorySizeLimitMB = directorySizeLimitMB === null ? null : directorySizeLimitMB * 1000000;
        this.createNewFileName('');
        this.callBeat();
        if (this._path !== null) {
            if (fs.existsSync(this._path)) {
                this.checkLogDirectorySize();
            }
            else {
                console.error('\n' + moment().format('YYYY-MM-DD-HH-mm-ss') + ' | ERROR | ' + this._path + ' directory is not exits (need for LoggerId)\n');
            }
        }
    }
    get path() {
        return this._path;
    }
    addType(type) {
        if (this._types.includes(type) === false) {
            this._types.push(type);
        }
    }
    getTimestamp(filename) {
        const date = filename.split('.')[0].split('_')[0].split('-');
        if (date.length === 6) {
            const numbers = date.map(e => parseInt(e, 10));
            return Date.parse(`${numbers[0]}-${numbers[1]}-${numbers[2]} ${numbers[3]}:${numbers[4]}:${numbers[5]}`);
        }
        else {
            return null;
        }
    }
    checkLogDirectorySize() {
        if (this._path === null) {
            return;
        }
        const files = readDirectory_1.readDirectory(this._path);
        if (files === null) {
            return;
        }
        const directorySize = Utils_1.default.sum(files.map(f => f.stats.size));
        if (directorySize > 1000000 * 10000) {
            const sizeInMB = Math.floor(directorySize / 1000000);
            this.warn(`Log directory size is more than ${sizeInMB}MB (${this._path})`);
        }
        if (this._directorySizeLimitMB !== null && directorySize > this._directorySizeLimitMB) {
            const deleteList = [];
            let space = 0;
            const minimumSpace = Math.floor(this._directorySizeLimitMB * 0.01);
            files.sort((a, b) => {
                const a1 = this.getTimestamp(a.name);
                const b1 = this.getTimestamp(b.name);
                if (a1 === null || b1 === null) {
                    return 0;
                }
                return a1 > b1 ? 1 : -1;
            }).some(file => {
                space += file.stats.size;
                deleteList.push(file.name);
                return space > minimumSpace;
            });
            deleteList.forEach(fileName => {
                if (this._path !== null) {
                    const file = path.join(this._path, fileName);
                    if (this.callListener('onDeleteLog', [file]).every(({ enabled }) => enabled !== false)) {
                        fs.unlinkSync(file);
                        this.warn(`Log file deleted (${file})`);
                    }
                }
            });
        }
    }
    onDeleteLog(callback) {
        this.addListener('onDeleteLog', callback);
    }
    getFileName(type) {
        if (type === null || type.length === 0) {
            return this._target[''] + '.txt';
        }
        if (this._target[type] === undefined) {
            this.addType(type);
            this.createNewFileName(type);
        }
        return this._target[type] + '_' + type + '.txt';
    }
    checkLogFiles() {
        if (this._path !== null) {
            this._types.forEach(type => {
                const fName = this.getFileName(type);
                if (fs.existsSync(fName)) {
                    const logFileSize = fs.statSync(fName).size;
                    if (logFileSize >= 2000000) {
                        this.createNewFileName(type);
                    }
                }
            });
        }
    }
    beat() {
        if (this._path !== null) {
            if (fs.existsSync(this._path)) {
                this.checkLogDirectorySize();
                this.checkLogFiles();
            }
            else {
                console.error('\n' + moment().format('YYYY-MM-DD-HH-mm-ss') + ' | ERROR | ' + this._path + ' directory is not exits (need for Logger4)\n');
            }
        }
    }
    callBeat() {
        this._timeout = setTimeout(() => {
            this._timeout = null;
            this.beat();
        }, 600000 - (new Date().getTime() + 600000) % 600000 + 1);
    }
    createNewFileName(type) {
        if (this._path !== null) {
            this._target[type] = path.join(this._path, moment().format('YYYY-MM-DD-HH-mm-ss'));
        }
    }
    save(tag, dateStr, log, type = null) {
        if (this._path !== null) {
            if (this._timeout === null) {
                this.callBeat();
            }
            try {
                fs.appendFileSync(this.getFileName(type), '\n' + dateStr + ' | ' + tag + ' | ' + log);
            }
            catch (e) {
                console.error(e);
            }
        }
    }
    formatLog(log, ...params) {
        if (params.length > 0) {
            try {
                log += ' | ' + JSON.stringify(params);
            }
            catch (e) {
                this.error(e.toString());
            }
        }
        return log.split('\n').map((line, i) => {
            return (i === 0) ? line : '\t\t' + line;
        }).join('\n');
    }
    print(log, tag, color, ...params) {
        const dateStr = Utils_1.default.getMomentDateString();
        log = params.length > 0 ? this.formatLog(log, ...params) : this.formatLog(log);
        this.save(tag, dateStr, log, null);
        console.log(color + dateStr + ' | ' + log + '\x1b[0m');
        this.callListener(tag, [log, null, ...params]);
    }
    on(tag, callback) {
        this.addListener(tag, callback);
    }
    onError(callback) {
        this.on('ERROR', callback);
    }
    error(log, ...params) {
        this.print(log, 'ERROR', '\x1b[31m', ...params);
    }
    onWarn(callback) {
        this.on('WARN', callback);
    }
    warn(log, ...params) {
        this.print(log, 'WARN', '\x1b[33m', ...params);
    }
    onSuccess(callback) {
        this.on('SUCCESS', callback);
    }
    success(log, ...params) {
        this.print(log, 'SUCCESS', '\x1b[32m', ...params);
    }
    onInfo(callback) {
        this.on('INFO', callback);
    }
    info(log, ...params) {
        this.print(log, 'INFO', '', ...params);
    }
    onDebug(callback) {
        this.on('DEBUG', callback);
    }
    debug(log, ...params) {
        this.save('DEBUG', Utils_1.default.getMomentDateString(), params.length > 0 ? this.formatLog(log, ...params) : this.formatLog(log), null);
        this.callListener('DEBUG', [log, null, ...params]);
    }
    hidden(log, tag = 'HIDDEN', type = null, ...params) {
        this.save(tag, Utils_1.default.getMomentDateString(), params.length > 0 ? this.formatLog(log, ...params) : this.formatLog(log), type);
        this.callListener(tag, [log, type, ...params]);
    }
}
exports.Logger4 = Logger4;
//# sourceMappingURL=Logger4.js.map